#### 프로젝트에 Spring Data Jpa 적용하기
    > build.gradle에 추가
```
    <필수사항>
    implementation('org.springframework.boot:spring-boot-starter-web')
    testImplementation('org.springframework.boot:spring-boot-starter-test')
    implementation('org.springframework.boot:spring-boot-starter-data-jpa')
    implementation('com.h2database:h2')
    implementation('org.projectlombok:lombok')
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    <이전에 추가한 것>
    testImplementation("org.junit.vintage:junit-vintage-engine") {
        exclude group: "org.hamcrest", module: "hamcrest-core"
    }
```

#### spring-boot-starter-data-jpa
    - 스프링 부트용 Spring Data Jpa 추상화 라이브러리
    - 스프링 부트 버저넹 맞춰 자동으로 JPA 관련 라이브러리들의 버전을 관리해 줌

#### h2
    - 인메모리 관계형 데이터베이스
    - 별도의 설치가 필요 없이 프로젝트 의존성만으로 관리할 수 있음
    - 메모리에서 실행되기 때문에 애플리케이션을 재시작할 때마다 초기화된다는 점을 이용하여 테스트 용도로 많이 사용
    - 별다른 설정 없이 @SpringBootTest를 사용할 경우 자동으로 H2 데이터베이스를 실행해 줌

#### 도메인
    - 게시글, 댓글, 회원, 정산, 결제 등 소프트웨어에 대한 요구사항 혹은 문제 영역
    - dao 패키지와는 조금 결이 다름

#### @Entity
    - JPA의 어노테이션
    - 테이블과 링크될 클래스임을 나타냄
    - 기본값으로 클래스의 카멜케이스 이름을 언더스코어 네이밍(_)으로 테이블 이름을 매칭함
    - 해당 클래스의 인스턴스 값들이 언제 어디서 변해야 하는지 코드상으로 명확하게 구분할 수가 없어 차후 기능 변경 시 복잡해지기 때문에 Entity 클래스에서는 절대 Setter 메소드를 만들지 않음
    - 기본 Repository 없이는 제대로 역할을 할 수 없음

#### @Id
    - 해당 테이블의 PK(PrimaryKey) 필드를 나타냄

#### @GeneratedValue
    - PK의 생성 규칙을 나타냄
    - 스프링 부트 2.0에서는 GeneratedType.IDENTITY 옵션을 추가해야만 auto_increment가 됨
    - 스프링 부트 2.0 버전과 1.5 버전의 차이는 https://jojoldu.tistory.com/295를 참고

#### @Column
    - 테이블의 칼럼을 나타내며 굳이 선언하지 않더라도 해당 클래스의 필드는 모두 칼럼이 됨
    - 사용하는 이유는 기본값 외에 추가로 변경이 필요한 옵션이 있으면 사용
    - 문자열의 경우 VARCHAR(255)가 기본값인데, 사이즈를 500으로 늘리고 싶거나(ex: title), 타입을 TEXT로 변경하고 싶거나(ex: content) 등의 경우에 사용됨

#### @NoArgsConstructor
    - 기본 생성자 자동 추가
    - public Posts() {} 와 같은 효과

#### @Getter
    - 클래스 내 모든 필드의 Getter 메소드를 자동 생성

#### @Builder
    - 해당 클래스의 빌더 패턴 클래스를 생성
    - 생성자 상단에 선언 시 생성자에 포함된 필드만 빌더에 포함

#### Setter가 없는 상황에서 어떻게 값을 채워 DB에 삽입하는가?
    - 기본적인 구조 : 생성자를 통해 최종값을 채운 후 DB에 삽입
    - 값 변경이 필요한 경우 해당 이벤트에 맞는 public 메소드를 호출하여 변경하는 것을 전제로 함

#### Repository
    - ibatis나 MyBatis 등에서는 Dao라고 불리는 DB Layer 접근자
    - JPA에서는 Repository라고 부르며 인터페이스로 생성
    - 인터페이스 생성 → JpaRepository<Entity 클래스, PK 타입> 상속 → 기본적인 CRUD 메소드가 자동으로 생성됨
    - @Repository를 추가할 필요도 없음
    - 단, Entity 클래스와 기본 Entity Repository는 함께 위치해야 함

#### RepositoryTest
    - save, findAll 기능을 테스트함

#### @After
    - Junit에서 단위 테스트가 끝날 때마다 수행되는 메소드를 지정
    - 보통은 배포 전 전체 테스트를 수행할 때 테스트간 데이터 침범을 막기 위해 사용
    - 여러 테스트가 동시에 수행되면 테스트용 데이터베이스인 H2에 데이터가 그대로 남아 있어 다음 테스트 실행 시 테스트가 실패할 수 있음

#### @postsRepository.save
    - 테이블 posts에 insert/update 쿼리를 실행함
    - id 값이 있다면 update가, 없다면 insert 쿼리가 실행됨

#### @postsRepository.findAll
    - 테이블 posts에 있는 모든 데이터를 조회해오는 메소드

#### 실제 실행된 쿼리 보기
    - 스프링 부트에서는 application.properties.application.yml 등의 파일로 한 줄의 코드로 설정 가능
    - src/main/resources 디렉토리 아래에 application.properties 파일 생성 → spring.jpa.show_sql=true 옵션 추가

#### id bigint generated by default as identity 옵션
    - 출력 쿼리의 문법이 H2의 쿼리 문법임
    - MySQL 버전으로 변경하려면 application.properties 파일에 spring.jpa.properties.hibernate.dialect-org.hibernate.dialect.MySQL5InnoDBDialect 옵션 추가

#### Web Layer
    - 흔히 사용하는 컨트롤러(@Controller)와 JSP/Freemarker 등의 뷰 템플릿 영역
    - 이외에도 필터(@Fillter), 인터셉터, 컨트롤러 어드바이스(@ControllerAdvice) 등 외부 요청과 응답에 대한 전반적인 영역을 의미

#### Service Layer
    - @Service에 사용되는 서비스 영역
    - 일반적으로 Controller와 Daoㅇ의 중간 영역에서 사용됨
    - @Transactional이 사용되어야 하는 영역이기도 함

#### Repository Layer
    - Database와 같이 데이터 저장소에 접근하는 영역
    - Dao(Data Access Object) 영역으로 이애하면 쉬움

#### Dtos
    - Dto(Data Tranfer Object) : 계층 간에 데이터 교환을 위한 객체
    - Dtos는 이들의 영역을 의미
    - 뷰 템플릿 엔진에서 사용될 객체나 Repository Layer에서 결과로 넘겨준 객체 등을 의미

#### Domain Model
    - 도메인이라 불리는 개발 대상을 모든 사람이 동일한 관점에서 이해할 수 있고 공유할 수 있도록 단순화시킨 것을 의미
    - ex) 택시 앱이라고 하면 배차, 탑승, 요금 등이 모두 도메인이 될 수 있음
    - @Entity가 사용된 영역 역시 도메인 모델
    - VO처럼 값 객체들도 이 영역에 해당되기 때문에 무조건 데이터베이스의 테이블과 관계가 있어야만 하는 것은 아님

#### 영속성 컨텍스트
    - 엔티티를 영구 저장하는 환경
    - 일종의 논리적 개념
    - JPA의 핵심 내용은 엔티티가 영속성 컨텍스트에 포함되어 있냐 아니냐로 갈림
    